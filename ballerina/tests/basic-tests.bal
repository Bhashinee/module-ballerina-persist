// Copyright (c) 2022 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
//
// WSO2 Inc. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/test;

@test:Config {
    groups: ["basic"]
}
function testCreate() returns error? {
    MedicalItemClient miClient = check new ();
    MedicalItem item = {
        itemId: 1,
        name: "item name",
        'type: "item type",
        unit: "ml"
    };
    MedicalItem item2 = check miClient->create(item);
    check miClient.close();
    test:assertEquals(item, item2);
}

@test:Config {
    groups: ["basic"]
}
function testCreateWithAutogeneratedKey() returns error? {
    MedicalNeedClient mnClient = check new ();
    MedicalNeed need = check mnClient->create({
        itemId: 1,
        beneficiaryId: 1,
        period: {year: 2022, month: 10, day: 10, hour: 1, minute: 2, second: 3},
        urgency: "URGENT",
        quantity: 5
    });
    check mnClient.close();
    test:assertTrue(need.needId is int);
}

@test:Config {
    groups: ["basic"],
    dependsOn: [testCreate]
}
function testReadByKey() returns error? {
    MedicalItemClient miClient = check new ();
    MedicalItem item = check miClient->readByKey(1);
    test:assertEquals(item, {
        itemId: 1,
        name: "item name",
        'type: "item type",
        unit: "ml"
    });
    check miClient.close();
}

@test:Config {
    groups: ["basic"],
    dependsOn: [testCreate]
}
function testReadByKeyNegative() returns error? {
    MedicalItemClient miClient = check new ();
    MedicalItem|error item = miClient->readByKey(20);
    if item is InvalidKeyError {
        test:assertEquals(item.message(), "A record does not exist for 'MedicalItem' for key 20.");
    } else {
        test:assertFail("Error expected.");
    }
    check miClient.close();
}

@test:Config {
    groups: ["basic"],
    dependsOn: [testCreate]
}
function testRead() returns error? {
    MedicalItemClient miClient = check new ();
    _ = check miClient->create({
        itemId: 2,
        name: "item2 name",
        'type: "type1",
        unit: "ml"
    });
    _ = check miClient->create({
        itemId: 3,
        name: "item2 name",
        'type: "type2",
        unit: "ml"
    });
    _ = check miClient->create({
        itemId: 4,
        name: "item2 name",
        'type: "type2",
        unit: "kg"
    });

    int count = 0;
    stream<MedicalItem, error?> itemStream = miClient->read({'type: "type1"});
    _ = check from MedicalItem _ in itemStream
        do {
            count = count + 1;
        };
    test:assertEquals(count, 1);

    count = 0;
    itemStream = miClient->read({'type: "type2"});
    _ = check from MedicalItem _ in itemStream
        do {
            count = count + 1;
        };
    check miClient.close();
    test:assertEquals(count, 2);
}

@test:Config {
    groups: ["basic"],
    dependsOn: [testCreate]
}
function testReadNegative() returns error? {
    MedicalItemClient miClient = check new ();
    stream<MedicalItem, error?> itemStream = miClient->read({typex: "type1"});
    int count = 0;
    error? err = from MedicalItem _ in itemStream
        do {
            count = count + 1;
        };
    if err is FieldDoesNotExistError {
        test:assertEquals(err.message(), "Field 'typex' does not exist in entity 'MedicalItem'.");
    } else {
        test:assertFail("Error expected");
    }
    check miClient.close();
}

@test:Config {
    groups: ["basic"],
    dependsOn: [testRead]
}
function testUpdate() returns error? {
    MedicalItemClient miClient = check new ();
    check miClient->update({"unit": "kg"}, {'type: "type2"});
    stream<MedicalItem, error?> itemStream = miClient->read();
    int count = 0;
    _ = check from MedicalItem item in itemStream
        do {
            if item.'type is "type2" {
                test:assertEquals(item.unit, "kg");
                count = count + 1;
            } else {
                test:assertEquals(item.unit, "ml");
            }
        };
    test:assertEquals(count, 2);
    check miClient.close();
}

@test:Config {
    groups: ["basic"],
    dependsOn: [testRead]
}
function testUpdateNegative() returns error? {
    MedicalItemClient miClient = check new ();
    error? result = miClient->update({"units": "kg"}, {'type: "type2"});
    if result is FieldDoesNotExistError {
        test:assertEquals(result.message(), "Field 'units' does not exist in entity 'MedicalItem'.");
    } else {
        test:assertFail("Error expected.");
    }
    check miClient.close();
}

@test:Config {
    groups: ["basic"],
    dependsOn: [testUpdate]
}
function testDelete() returns error? {
    MedicalItemClient miClient = check new ();
    check miClient->delete({'type: "type2"});
    stream<MedicalItem, error?> itemStream = miClient->read();
    int count = 0;
    _ = check from MedicalItem _ in itemStream
        do {
            count = count + 1;
        };
    test:assertEquals(count, 2);
    check miClient.close();
}

@test:Config {
    groups: ["basic"],
    dependsOn: [testUpdate]
}
function testDeleteNegative() returns error? {
    MedicalItemClient miClient = check new ();
    error? result = miClient->delete({'types: "type2"});
    if result is FieldDoesNotExistError {
        test:assertEquals(result.message(), "Field 'types' does not exist in entity 'MedicalItem'.");
    } else {
        test:assertFail("Error expected.");
    }
    check miClient.close();
}

@test:Config {
    groups: ["basic"]
}
function testComplexTypes() returns error? {
    MedicalNeed need = {
        itemId: 1,
        beneficiaryId: 1,
        period: {year: 2022, month: 10, day: 10, hour: 1, minute: 2, second: 3},
        urgency: "URGENT",
        quantity: 5
    };
    MedicalNeedClient mnClient = check new ();
    MedicalNeed need2 = check mnClient->create(need);
    test:assertTrue(need2.needId is int);

    MedicalNeed need3 = check mnClient->readByKey(need2.needId);
    test:assertEquals(need.itemId, need3.itemId);
    test:assertEquals(need.beneficiaryId, need3.beneficiaryId);
    test:assertEquals(need.period, need3.period);
    test:assertEquals(need.urgency, need3.urgency);
    test:assertEquals(need.quantity, need3.quantity);

    check mnClient.close();
}

@test:Config {
    groups: ["basic"]
}
function testComplexTypes2() returns error? {
    MedicalNeed need = {
        itemId: 1,
        beneficiaryId: 1,
        period: {year: 2022, month: 10, day: 10, hour: 1, minute: 2, second: 3},
        urgency: "URGENT",
        quantity: 5
    };
    MedicalNeedClient mnClient = check new ();
    MedicalNeed need2 = check mnClient->create(need);
    test:assertTrue(need2.needId is int);

    stream<MedicalNeed, error?> needStream = mnClient->read({itemId: 1});
    int count = 0;
    _ = check from MedicalNeed need3 in needStream
        do {
            test:assertEquals(need2.itemId, 1);
            count = count + 1;
        };
    test:assertTrue(count > 0);

    check mnClient.close();
}

@test:Config {
    groups: ["basic"]
}
function testComplexTypesWithExecute() returns error? {
    MedicalNeed need = {
        itemId: 1,
        beneficiaryId: 1,
        period: {year: 2022, month: 10, day: 10, hour: 1, minute: 2, second: 3},
        urgency: "URGENT",
        quantity: 5
    };
    MedicalNeedClient mnClient = check new ();
    MedicalNeed need2 = check mnClient->create(need);
    test:assertTrue(need2.needId is int);

    int count = 0;
    _ = check from MedicalNeed need3 in mnClient->execute(` WHERE itemId = 1`)
        do {
            test:assertEquals(need2.itemId, 1);
            count = count + 1;
        };
    test:assertTrue(count > 0);

    check mnClient.close();
}

